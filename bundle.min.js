! function() {
    "use strict";
    class t {
        constructor(t, e, n) {
            this.variables = [], this.currentTextureIndex = 0;
            let r = THREE.FloatType;
            const o = new THREE.Scene,
                a = new THREE.Camera;
            a.position.z = 1;
            const i = {
                    passThruTexture: {
                        value: null
                    }
                },
                s = d("uniform sampler2D passThruTexture;\n\nvoid main() {\n\n vec2 uv = gl_FragCoord.xy / resolution.xy;\n\n  gl_FragColor = texture2D( passThruTexture, uv );\n\n}\n", i),
                c = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), s);

            function l(n) {
                n.defines.resolution = "vec2( " + t.toFixed(1) + ", " + e.toFixed(1) + " )"
            }

            function d(t, e) {
                e = e || {};
                const n = new THREE.ShaderMaterial({
                    uniforms: e,
                    vertexShader: "void main() {\n\n gl_Position = vec4( position, 1.0 );\n\n}\n",
                    fragmentShader: t
                });
                return l(n), n
            }
            o.add(c), this.setDataType = function(t) {
                return r = t, this
            }, this.addVariable = function(t, e, n) {
                const r = {
                    name: t,
                    initialValueTexture: n,
                    material: this.createShaderMaterial(e),
                    dependencies: null,
                    renderTargets: [],
                    wrapS: null,
                    wrapT: null,
                    minFilter: THREE.NearestFilter,
                    magFilter: THREE.NearestFilter
                };
                return this.variables.push(r), r
            }, this.setVariableDependencies = function(t, e) {
                t.dependencies = e
            }, this.init = function() {
                if (!1 === n.capabilities.isWebGL2 && !1 === n.extensions.has("OES_texture_float")) return "No OES_texture_float support for float textures.";
                if (0 === n.capabilities.maxVertexTextures) return "No support for vertex shader textures.";
                for (let n = 0; n < this.variables.length; n++) {
                    const r = this.variables[n];
                    r.renderTargets[0] = this.createRenderTarget(t, e, r.wrapS, r.wrapT, r.minFilter, r.magFilter), r.renderTargets[1] = this.createRenderTarget(t, e, r.wrapS, r.wrapT, r.minFilter, r.magFilter), this.renderTexture(r.initialValueTexture, r.renderTargets[0]), this.renderTexture(r.initialValueTexture, r.renderTargets[1]);
                    const o = r.material,
                        a = o.uniforms;
                    if (null !== r.dependencies)
                        for (let t = 0; t < r.dependencies.length; t++) {
                            const e = r.dependencies[t];
                            if (e.name !== r.name) {
                                let t = !1;
                                for (let n = 0; n < this.variables.length; n++)
                                    if (e.name === this.variables[n].name) {
                                        t = !0;
                                        break
                                    }
                                if (!t) return "Variable dependency not found. Variable=" + r.name + ", dependency=" + e.name
                            }
                            a[e.name] = {
                                value: null
                            }, o.fragmentShader = "\nuniform sampler2D " + e.name + ";\n" + o.fragmentShader
                        }
                }
                return this.currentTextureIndex = 0, null
            }, this.compute = function() {
                const t = this.currentTextureIndex,
                    e = 0 === this.currentTextureIndex ? 1 : 0;
                for (let n = 0, r = this.variables.length; n < r; n++) {
                    const r = this.variables[n];
                    if (null !== r.dependencies) {
                        const e = r.material.uniforms;
                        for (let n = 0, o = r.dependencies.length; n < o; n++) {
                            const o = r.dependencies[n];
                            e[o.name].value = o.renderTargets[t].texture
                        }
                    }
                    this.doRenderTarget(r.material, r.renderTargets[e])
                }
                this.currentTextureIndex = e
            }, this.getCurrentRenderTarget = function(t) {
                return t.renderTargets[this.currentTextureIndex]
            }, this.getAlternateRenderTarget = function(t) {
                return t.renderTargets[0 === this.currentTextureIndex ? 1 : 0]
            }, this.addResolutionDefine = l, this.createShaderMaterial = d, this.createRenderTarget = function(n, o, a, i, s, c) {
                n = n || t, o = o || e, a = a || THREE.ClampToEdgeWrapping, i = i || THREE.ClampToEdgeWrapping, s = s || THREE.NearestFilter, c = c || THREE.NearestFilter;
                return new THREE.WebGLRenderTarget(n, o, {
                    wrapS: a,
                    wrapT: i,
                    minFilter: s,
                    magFilter: c,
                    format: THREE.RGBAFormat,
                    type: r,
                    depthBuffer: !1
                })
            }, this.createTexture = function() {
                const n = new Float32Array(t * e * 4);
                return new THREE.DataTexture(n, t, e, THREE.RGBAFormat, THREE.FloatType)
            }, this.renderTexture = function(t, e) {
                i.passThruTexture.value = t, this.doRenderTarget(s, e), i.passThruTexture.value = null
            }, this.doRenderTarget = function(t, e) {
                const r = n.getRenderTarget();
                c.material = t, n.setRenderTarget(e), n.render(o, a), c.material = s, n.setRenderTarget(r)
            }
        }
    }
    var e = THREE;
    let n = "\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat cnoise(vec3 P){\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}",
        r = "\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec4 fade(vec4 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat cnoise(vec4 P){\n  vec4 Pi0 = floor(P); // Integer part for indexing\n  vec4 Pi1 = Pi0 + 1.0; // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec4 Pf0 = fract(P); // Fractional part for interpolation\n  vec4 Pf1 = Pf0 - 1.0; // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = vec4(Pi0.zzzz);\n  vec4 iz1 = vec4(Pi1.zzzz);\n  vec4 iw0 = vec4(Pi0.wwww);\n  vec4 iw1 = vec4(Pi1.wwww);\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n  vec4 ixy00 = permute(ixy0 + iw0);\n  vec4 ixy01 = permute(ixy0 + iw1);\n  vec4 ixy10 = permute(ixy1 + iw0);\n  vec4 ixy11 = permute(ixy1 + iw1);\n\n  vec4 gx00 = ixy00 / 7.0;\n  vec4 gy00 = floor(gx00) / 7.0;\n  vec4 gz00 = floor(gy00) / 6.0;\n  gx00 = fract(gx00) - 0.5;\n  gy00 = fract(gy00) - 0.5;\n  gz00 = fract(gz00) - 0.5;\n  vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);\n  vec4 sw00 = step(gw00, vec4(0.0));\n  gx00 -= sw00 * (step(0.0, gx00) - 0.5);\n  gy00 -= sw00 * (step(0.0, gy00) - 0.5);\n\n  vec4 gx01 = ixy01 / 7.0;\n  vec4 gy01 = floor(gx01) / 7.0;\n  vec4 gz01 = floor(gy01) / 6.0;\n  gx01 = fract(gx01) - 0.5;\n  gy01 = fract(gy01) - 0.5;\n  gz01 = fract(gz01) - 0.5;\n  vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);\n  vec4 sw01 = step(gw01, vec4(0.0));\n  gx01 -= sw01 * (step(0.0, gx01) - 0.5);\n  gy01 -= sw01 * (step(0.0, gy01) - 0.5);\n\n  vec4 gx10 = ixy10 / 7.0;\n  vec4 gy10 = floor(gx10) / 7.0;\n  vec4 gz10 = floor(gy10) / 6.0;\n  gx10 = fract(gx10) - 0.5;\n  gy10 = fract(gy10) - 0.5;\n  gz10 = fract(gz10) - 0.5;\n  vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);\n  vec4 sw10 = step(gw10, vec4(0.0));\n  gx10 -= sw10 * (step(0.0, gx10) - 0.5);\n  gy10 -= sw10 * (step(0.0, gy10) - 0.5);\n\n  vec4 gx11 = ixy11 / 7.0;\n  vec4 gy11 = floor(gx11) / 7.0;\n  vec4 gz11 = floor(gy11) / 6.0;\n  gx11 = fract(gx11) - 0.5;\n  gy11 = fract(gy11) - 0.5;\n  gz11 = fract(gz11) - 0.5;\n  vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);\n  vec4 sw11 = step(gw11, vec4(0.0));\n  gx11 -= sw11 * (step(0.0, gx11) - 0.5);\n  gy11 -= sw11 * (step(0.0, gy11) - 0.5);\n\n  vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);\n  vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);\n  vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);\n  vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);\n  vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);\n  vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);\n  vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);\n  vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);\n  vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);\n  vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);\n  vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);\n  vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);\n  vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);\n  vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);\n  vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);\n  vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);\n\n  vec4 norm00 = taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));\n  g0000 *= norm00.x;\n  g0100 *= norm00.y;\n  g1000 *= norm00.z;\n  g1100 *= norm00.w;\n\n  vec4 norm01 = taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));\n  g0001 *= norm01.x;\n  g0101 *= norm01.y;\n  g1001 *= norm01.z;\n  g1101 *= norm01.w;\n\n  vec4 norm10 = taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));\n  g0010 *= norm10.x;\n  g0110 *= norm10.y;\n  g1010 *= norm10.z;\n  g1110 *= norm10.w;\n\n  vec4 norm11 = taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));\n  g0011 *= norm11.x;\n  g0111 *= norm11.y;\n  g1011 *= norm11.z;\n  g1111 *= norm11.w;\n\n  float n0000 = dot(g0000, Pf0);\n  float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));\n  float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));\n  float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));\n  float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));\n  float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));\n  float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));\n  float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));\n  float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));\n  float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));\n  float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));\n  float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));\n  float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));\n  float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));\n  float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));\n  float n1111 = dot(g1111, Pf1);\n\n  vec4 fade_xyzw = fade(Pf0);\n  vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);\n  vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);\n  vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);\n  vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);\n  float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);\n  return 2.2 * n_xyzw;\n}",
        o = "\nvec3 rotAxis(vec3 v, vec3 axis, float angle)\n{\nreturn (1.0 - cos(angle)) * dot(v, axis) * axis + cos(angle) * v + sin(angle) * cross(axis, v);\n}",
        a = (i = document.createElement("a"), document.body.appendChild(i), i.style = "display: none", function(t, e) {
            let n = window.URL.createObjectURL(t);
            i.href = n, i.download = e, i.click(), window.URL.revokeObjectURL(n)
        });
    var i;

    function s(t, e, n, r, o, a = !1) {
        let i = r + (o - r) * (t - e) / (n - e);
        return a && (i = function(t, e, n) {
            return t < e && (t = e), t > n && (t = n), t
        }(i, r, o)), i
    }
    let c = new class {
            constructor() {}
            random_dec() {
                return fxrand()
            }
            random_num(t, e) {
                return t + (e - t) * this.random_dec()
            }
            random_int(t, e) {
                return Math.floor(this.random_num(t, e + 1))
            }
            random_bool(t) {
                return this.random_dec() < t
            }
            random_choice(t) {
                return t[this.random_int(0, t.length - 1)]
            }
        },
        l = [
            [
                [789516, 1776411, 11184810, 13421772, 9509408],
                [13160146, 8491933],
                [16512245, 10720405],
                [16740685, 10158144],
                [43724, 1192593],
                [16241510, 16284179],
                [16774535, 11437634]
            ],
            [
                [789516, 1314315, 3419444, 10723752, 11446688],
                [9404047, 5326417],
                [13938624, 5326417],
                [6173257, 2296601],
                [13935545, 3479848],
                [13477543, 10050398],
                [16763838, 15368551],
                [16777215, 10723752],
                [11713981, 4081221],
                [16774535, 11437634],
                [2641761, 398105],
                [16117473, 11446688],
                [16740685, 10158144]
            ],
            [
                [1776411, 4081221, 13009778],
                [2105376, 263172],
                [7434609, 1776411],
                [13816530, 7697781],
                [10979201, 3022104],
                [11713981, 4081221],
                [16512245, 10720405],
                [16758693, 13726812],
                [16740685, 10158144]
            ],
            [
                [1188651, 5862003, 13420222],
                [2105376, 263172],
                [7434609, 1776411],
                [13816530, 7697781],
                [11713981, 4081221],
                [16512245, 10720405],
                [16763838, 12610132],
                [2641761, 398105],
                [16777215, 10723752]
            ],
            [
                [11184810, 13420222, 789516, 5642267],
                [16777215, 10723752],
                [12098440, 10773328],
                [13160146, 8491933],
                [7304571, 2632233],
                [13816530, 11184810],
                [9346721, 5068890],
                [8500417, 4345958],
                [6716013, 2238234],
                [16740685, 10158144],
                [16774535, 11437634]
            ],
            [
                [789516, 13421772, 526860],
                [263172, 0],
                [6776679, 0],
                [2105376, 263172],
                [1777441, 197380],
                [2170138, 262915],
                [7434609, 1776411],
                [16777215, 10723752],
                [16777215, 11710378],
                [9346721, 5068890]
            ],
            [
                [1317398, 11446688, 4938320, 9609377],
                [12111313, 5068890],
                [16774535, 11437634],
                [16740685, 10158144]
            ],
            [
                [526860, 8362123, 11446688, 5642267],
                [263172, 0],
                [16043429, 11884339],
                [16643243, 15241802],
                [16710626, 6376764],
                [16740685, 10158144],
                [8821388, 3424830],
                [9097389, 3758933],
                [16777215, 11710378]
            ]
        ],
        d = c.random_int(0, l.length - 1),
        v = l[d][0],
        g = c.random_int(0, v.length - 1),
        u = c.random_int(1, l[d].length - 1);
    c.random_bool(.2) && (u = l[d].length - 1);
    for (let t = 0; t < c.random_int(1, 100); t++) c.random_dec();
    let m = c.random_dec() < .9 ? .5 : 1,
        f = c.random_dec();
    c.random_dec() > .5 && (f = 1 - f), f = 1 - Math.pow(1 - f * m, 2);
    let x = Math.pow(1 - f, 3),
        p = Math.ceil(s(f, 0, 1, 200, 1e3)),
        y = Math.ceil(s(x, 0, 1, 60, 140)),
        h = c.random_bool(.5);
    p = Math.floor(p);
    let w = .009,
        P = [];
    for (let t = 2; t < 9; t++) {
        let e = [];
        for (let n = 2; n < 12; n++) t != n && e.push([t, n]);
        P.push(e)
    }
    let z = P[Math.floor(Math.pow(c.random_dec(), 2) * P.length)],
        _ = z[Math.floor(Math.pow(c.random_dec(), 2.5) * z.length)],
        b = .6,
        T = _[0],
        S = _[1],
        R = 0,
        C = c.random_bool(.9),
        D = c.random_num(1, 2),
        E = c.random_bool(.5) ? -1 : 1,
        M = c.random_num(.4, .7),
        $ = Math.floor(4.1 * Math.pow(c.random_dec(), 1)),
        F = c.random_bool(.1);
    F && ($ = 1);
    let A = c.random_num(1, 4),
        I = 0;
    C && !c.random_bool(.1) || (I = c.random_num(.01, .05)), C ? M *= 1 + Math.pow(.15 * T, 2) : (D *= .4, M *= 1.5);
    let V = c.random_int(1, 2),
        H = c.random_num(.25, .45);
    1 == V && (H *= 1.5);
    let L = c.random_num(H + .1, .6);
    c.random_num(0, .1 * x);
    let k = 1 + Math.round(20 * Math.pow(c.random_dec(), 2)),
        j = c.random_bool(.8);
    V <= 1 && (j = !0), j && (k += 1);
    let O = Math.pow(1 - f, 2);
    O *= .2 * c.random_dec();
    let B = c.random_bool(.05),
        N = c.random_bool(.5),
        q = c.random_num(-1, 1),
        W = .011 + .005 * x,
        G = .24,
        U = c.random_num(1.1, 3.2),
        Y = c.random_num(0, .2),
        X = c.random_bool(.5),
        K = c.random_num(10, 30),
        Q = c.random_num(5, 20),
        Z = c.random_num(.2, .7),
        J = -1;
    c.random_bool(.4) && (J = c.random_int(0, 3)), 0 == J ? (p = 4e3, y = 17, B = !1, w = .008, V = 1, O = .1, M = c.random_num(.8, 1.5), R = c.random_num(.01, .03), Z = c.random_num(.3, .7)) : 1 == J ? (p = 100, y = 180, w = .006, O = .1, M = 1, $ = 3, G = .24, Z = .3) : 2 == J ? (p = 100, y = 200, w = .005, O = .01, M = 1, $ = 2, G = .3, F = !1) : 3 == J && (p = c.random_int(30, 60), y = 300, w = c.random_num(.01, .015), O = .01, M *= 1.5, $ = 3, G = .4, F = !1, h = !0, j = !0, H = c.random_num(.3, .45), 1 == V && (H *= 1.5), L = c.random_num(H + .1, .6)), f = s(p, 30, 1e3, 0, 1, !0), !C && c.random_bool(.7) && (b = c.random_num(.5, .7), c.random_bool(.1) && (q = c.random_num(.5, 1), q *= c.random_bool(.5) ? -1 : 1));
    let tt = function(t) {
            let e = function(t) {
                return {
                    r: (t >> 16 & 255) / 255,
                    g: (t >> 8 & 255) / 255,
                    b: (255 & t) / 255
                }
            }(t);
            return (e.r + e.g + e.b) / 3
        }(v[g]),
        et = c.random_bool(.5) ? 1 : 2;
    tt < .04 && (et = 0);
    let nt = u / 3 * (1 + 1 * f);
    nt *= c.random_int(1, 3), 0 == J && (nt = 1.5), nt < 1 && (nt = 1), 2 == $ && M < 1.3 && (M = 1.3);
    let rt = !1;
    C && (rt = c.random_bool(.05));
    let ot = {
        nLinesRat: f,
        nStepsRat: x,
        strayRatio: O,
        nLines: p,
        nSteps: y,
        minThickness: w,
        nSides: 5,
        shortenRibbons: h,
        colorSchemeIndex: d,
        numColors: u,
        bgColorIndex: g,
        ribbonType: $,
        torusP: T,
        torusQ: S,
        torusThickness: R,
        torusExtraRev: C,
        torusRevolve: N,
        torusStartRad: b,
        reverse: c.random_bool(.5),
        twist: q,
        twistAxis: [0, 1, c.random_dec()],
        noiseOffset0: c.random_dec(),
        noiseOffset1: c.random_dec(),
        neuronScale: A,
        neuronSpeed: I,
        revolveRat: D,
        revolveDir: E,
        revolveDir: E,
        thicknessVarySpeed: c.random_num(.01, .1),
        spherize: B,
        spherizeNum: c.random_num(1, 3),
        glitch: c.random_bool(.2),
        shapeConstrain: rt,
        speed: M,
        numPlanets: k,
        centerPlanet: j,
        nCores: V,
        coreInnerRad: H,
        coreOuterRad: L,
        shellRepulsionDistance: G,
        shellRepulsionStrength: W,
        shellNoiseSize: U,
        shellOpenness: Y,
        variation: J,
        typeSpreadChaos: X,
        typeSpread: K,
        typeInternalSpread: Q,
        typeDistPow: nt,
        spikey: F,
        thinProbability: Z,
        gradientType: et
    };

    function at(t) {
        return t ? "Yes" : "No"
    }
    let it = "\nadder = 1.0 / torusQ;\np0 = p0 + rotAxis(yDir, tan, (t1 * adder)) * rad2;\np  = p + rotAxis(yDir, tan, (t1 * adder)) * rad2;\np2 = p2 + rotAxis(yDir, tan, (t1 * adder)) * rad2;\n",
        st = `\nfloat twist0 = p0.y * ${ot.twist.toPrecision(5)};\nfloat twist = p.y * ${ot.twist.toPrecision(5)};\nfloat twist2 = p2.y * ${ot.twist.toPrecision(5)};\n\nvec3 axis = vec3(${ot.twistAxis[0].toPrecision(5)}, ${ot.twistAxis[1].toPrecision(5)}, ${ot.twistAxis[2].toPrecision(5)});\n\np0 = rotAxis(p0, axis, twist0);\np = rotAxis(p, axis, twist);\np2 = rotAxis(p2, axis, twist2);\n\n`,
        ct = `\nt /= ${ot.torusQ.toPrecision(5)};\nv.z = sin(t) * v.x;\nv.x = cos(t) * v.x;`;
    ot.torusRevolve || (ct = "");
    let lt = `\nvec3 calcStep (float t, float rad) \n{\nvec3 v;\nv.x = sin(t) * rad;\nv.y = cos(t) * rad;\n\n${ct}\n\nreturn v;\n}\n`;
    ot.torusExtraRev || (it = "");
    let dt = `t1 += (sin(uv.y * ${c.random_num(350,1e3).toPrecision(5)}) * ${c.random_num(10,20).toPrecision(5)}) * 3.321;`,
        vt = `\nif (type >= 1.0)\n{\nt1 *= .6 + (type * 0.1);\nt1 += type * ${ot.typeSpread.toPrecision(5)}; // type spread\nt1 += sin(uv.y * 350.0) * ${ot.typeInternalSpread.toPrecision(5)}; //internal spread\n}\nelse\n{\n${dt}\n}`;
    ot.typeSpreadChaos && (vt = dt);
    let gt = THREE,
        ut = new gt.Texture;
    let mt = THREE,
        ft = new mt.Texture;
    let xt = THREE;
    let pt = "";
    1 == ot.gradientType ? pt = "gl_FragColor -= (pow(uv.y, 2.5)) * 0.1; // gradient" : 2 == ot.gradientType && (pt = "gl_FragColor += (pow(uv.y, 2.5)) * 0.15; // gradient");
    let yt = THREE,
        ht = window;
    /\bHeadlessChrome/.test(navigator.userAgent);
    let wt = new class {
            _rotVel = new e.Vector3;
            _posVel;
            _prevMousePos;
            _isMouseDown;
            constructor() {
                this._posVel = new e.Vector3, this._prevMousePos = {
                    x: 0,
                    y: 0
                }, this._isMouseDown = !1, window.addEventListener("touchstart", this._mouseDownHandler.bind(this)), window.addEventListener("touchend", this._mouseUpHandler.bind(this)), window.addEventListener("touchmove", this._mouseMoveHandler.bind(this)), window.addEventListener("mousedown", this._mouseDownHandler.bind(this)), window.addEventListener("mouseup", this._mouseUpHandler.bind(this)), window.addEventListener("mousemove", this._mouseMoveHandler.bind(this)), window.addEventListener("wheel", this._mouseWheelHandler.bind(this), {
                    passive: !1
                })
            }
            update(t) {
                t = t || .9;
                this._posVel.multiplyScalar(t), this._rotVel.multiplyScalar(t)
            }
            getRotationVelocity() {
                return this._rotVel
            }
            getPositionVelocity() {
                return this._posVel
            }
            _mouseDownHandler(t) {
                this._prevMousePos = {
                    x: t.pageX,
                    y: t.pageY
                }, this._isMouseDown = !0
            }
            _mouseUpHandler(t) {
                this._isMouseDown = !1
            }
            _mouseMoveHandler(t) {
                if (this._isMouseDown) {
                    var e = {
                        x: t.pageX - this._prevMousePos.x,
                        y: t.pageY - this._prevMousePos.y
                    };
                    this._prevMousePos = {
                        x: t.pageX,
                        y: t.pageY
                    }, this._rotVel.x = e.y / 200, this._rotVel.y = e.x / 200
                }
                t.preventDefault()
            }
            _mouseWheelHandler(t) {
                var e = t.deltaY;
                this._posVel.z += e / 5e3, t.preventDefault()
            }
        },
        Pt = new yt.Vector3(c.random_num(-.6, .6), c.random_num(-1, 1), 0);
    Pt.normalize();
    let zt = .01,
        _t = zt;
    window.matchMedia("only screen and (max-width: 1024px)").matches;
    let bt, Tt, St, Rt, Ct, Dt, Et, Mt, $t, Ft, At, It, Vt, Ht, Lt, kt = ht.devicePixelRatio ? ht.devicePixelRatio : 1,
        jt = ht.innerWidth,
        Ot = ht.innerHeight;
    isFxpreview && (jt = Ot);
    let Bt, Nt, qt, Wt, Gt, Ut, Yt, Xt, Kt, Qt, Zt, Jt, te, ee, ne, re, oe, ae, ie = !1,
        se = 0,
        ce = 0,
        le = Me(),
        de = 0,
        ve = 0,
        ge = 2,
        ue = !1,
        me = .3,
        fe = [],
        xe = [],
        pe = ot.nSides,
        ye = ot.nLines,
        he = ot.nSteps,
        we = .6,
        Pe = 0,
        ze = !1,
        _e = !1,
        be = !1,
        Te = [],
        Se = [];
    ge *= kt;
    let Re = !1;
    kt <= 1 && (Re = !0, jt *= 2, Ot *= 2);
    let Ce = `\nvec4 tmpPos = pos;\n\nfloat torusP = ${ot.torusP.toPrecision(5)};\nfloat torusQ = ${ot.torusQ.toPrecision(5)};\n\nfloat t1 = time * 0.5;\nt1 *= ${ot.speed.toPrecision(5)};\nt1 *= ((1.0 + sin(uv.y * 13.45) / 2.0) * 2.0) + .1;\n\n${vt}\n\nt1 *= ${(ot.reverse?-1:1).toPrecision(5)};\n\n\nfloat rad1 = ${ot.torusStartRad.toPrecision(5)};\nfloat rad2 = rad1 * 0.5;\n\nfloat step = 0.2;\n\nfloat adder = 1.0 / torusP;\nvec3 p0 = calcStep((t1 - step) * adder, rad1);\np = calcStep(t1 * adder, rad1);\nvec3 p2 = calcStep((t1 + step) * adder, rad1);\nvec3 prevTan = normalize(p0 - p);\nvec3 tan = normalize(p2 - p);\nvec3 yDir = cross(tan, normalize(tan - prevTan));\nyDir = normalize(yDir);\n\n\nif (${ot.shapeConstrain} && cnoise(vec4(uv.y * 2.3, 0.0, 0.0, 1.0)) > -0.0)\n{\nfloat siz = .5 * (1.0 + floor(1.0 + sin(uv.y * 3.42)));\nsiz = .4;\n//p0 *= 1.0 - sdOctahedron(p0, siz);\n//p = normalize(p);\np *= 1.0 - sdOctahedron(p, siz);\n//p2 *= 1.0 - sdOctahedron(p2, siz);\n}\n\n\n${it}\n${st}\n\nif (uv.y < .7 && ${ot.spherize})\n{\np = normalize(p) * (0.3 + (floor(sin(uv.y * 23.2) * ${ot.spherizeNum}) * .3)); // spherize\n}\n\nprevTan = normalize(p0 - p);\ntan = normalize(p2 - p);\nyDir = cross(tan, normalize(tan - prevTan));\nyDir = normalize(yDir);\n\nadder = ${c.random_num(.5,1).toPrecision(5)} - (torusP * 0.05);\nadder *= ${ot.revolveRat.toPrecision(5)};\nadder *= ${ot.revolveDir.toPrecision(5)};\n\nfloat thicken = cnoise(vec4(((p.xyz * 1.2 + ${432.4*ot.noiseOffset1})), time * ${ot.neuronSpeed.toPrecision(5)}));\nthicken = pow(thicken, 3.0) * ${ot.neuronScale};\nthicken += ${ot.torusThickness.toPrecision(5)};\n\n//thicken = .5 - thicken;\n//if (sin(uv.y * 44.4) < -${1-ot.strayRatio}) \n\nif (uv.y < ${ot.strayRatio.toPrecision(5)})\n{\nthicken += 1.0 + sin(uv.y * 123.4) * 2.5;\n//thicken += 0.5;\ntype += 100.0;\n}\n\np  = p + rotAxis(yDir, tan, (t1 * adder) + (uv.y * PI * 2.0)) * (rad2 * thicken);\n`;

    function De(t) {
        let e = t.clone();
        e.addScalar(.22);
        let n = re.clone();
        return n.addScalar(-.22), [e, n]
    }

    function Ee() {
        xe = [];
        for (let t = 0; t < fe.length; t++) {
            let e = fe[t];
            e.rotationY += .003 * Math.sin(t + 1), e.rotationZ += .005 * Math.cos(t + 3);
            let n = new yt.Vector4;
            n.x = Math.cos(e.rotationZ) * e.rad, n.y = Math.sin(e.rotationZ) * e.rad, n.z = Math.sin(e.rotationY) * n.x, n.x = Math.cos(e.rotationY) * n.x, n.w = e.scale, e.pos = n, xe.push(n);
            let r = new yt.Matrix4;
            r.scale(new yt.Vector3(e.scale, e.scale, e.scale)), r.setPosition(new yt.Vector3(n.x, n.y, n.z)), Jt.setMatrixAt(t, r)
        }
        Jt.instanceMatrix.needsUpdate = !0
    }

    function Me() {
        return (new Date).getTime()
    }

    function $e(t) {
        Pe += .01 * (we - Pe), ue || (ce += t, bt.compute()), wt.update(.95), ue || Ee(), me < .4 && (me += .005 * (.4 - me)), Ct.material.uniforms.maxAcc = {
            value: me
        };
        let e = wt.getRotationVelocity().clone();
        e.length() > 0 && (_t = e.length(), Pt = e.normalize()), ue ? _t *= .9 : !wt._isMouseDown && _t < zt && (_t = zt), Wt.rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), Pt.y * _t), Wt.rotateOnWorldAxis(new THREE.Vector3(1, 0, 0), Pt.x * _t), /*!isHeadless && */ ce < 5 && (Wt.position.z = -3 * Math.pow(1 - ce / 5, 2)), $t.material.uniforms.time = {
            value: ce
        }, $t.material.uniforms.frame = {
            value: de
        }, St.material.uniforms.time = {
            value: ce
        }, St.material.uniforms.frame = {
            value: de
        }, ee.uniforms.time = {
            value: ce
        }, ee.uniforms.posTex = {
            value: bt.getCurrentRenderTarget($t).texture
        }, ee.wireframe = _e, Ct.material.uniforms.time = {
            value: ce
        }, Ct.material.uniforms.repulsors = {
            value: xe
        };
        let n = de <= he ? de : he;
        if (Kt.material.uniforms.numSteps = {
                value: n
            }, Kt.material.uniforms.time = {
                value: ce
            }, Kt.material.uniforms.posTex = {
                value: bt.getCurrentRenderTarget($t).texture
            }, Kt.material.uniforms.xDirTex = {
                value: bt.getCurrentRenderTarget(Vt).texture
            }, Kt.material.uniforms.yDirTex = {
                value: bt.getCurrentRenderTarget(Lt).texture
            }, Kt.material.uniforms.tanTex = {
                value: bt.getCurrentRenderTarget(At).texture
            }, Kt.material.uniforms.mouseRat = {
                value: Pe
            }, Kt.material.wireframe = _e, !isFxpreview || de > 1200) {
            let t = Bt.getRenderTarget();
            Bt.setRenderTarget(te), Bt.render(Nt, qt), Yt.material.uniforms.map.value = te.texture, Yt.material.uniforms.time.value = se, Yt.material.uniforms.width.value = jt, Yt.material.uniforms.height.value = Ot, Yt.material.uniforms.noiseStrength.value = be ? .6 : .8, Bt.setRenderTarget(t), ze ? Bt.render(oe, Ut) : Bt.render(Gt, Ut)
        }
        ie || (we = (1 + Math.sin(.1 * ce - .5 * Math.PI)) / 2), ue || de++
    }! function() {
        ne = l[ot.colorSchemeIndex], ne = ne.map((t => t.map((t => new yt.Color(t)))));
        let t = ne.splice(0, 1)[0];
        re = t[ot.bgColorIndex];
        let e = [],
            n = ot.numColors,
            r = ne.slice();
        for (let t = 0; t < n; t++) {
            let t = c.random_int(0, r.length - 1);
            e.push(r.splice(t, 1)[0])
        }(0 == ot.colorSchemeIndex || 1 == n || c.random_dec() > .5) && (e.unshift(De(re)), e.unshift(De(re)));
        if (0 == ot.variation) {
            let t = (re.r + re.b + re.g) / 3,
                n = 0,
                r = 0;
            for (let e = 0; e < ne.length; e++) {
                let o = ne[e][0],
                    a = (o.r + o.b + o.g) / 3,
                    i = Math.abs(t - a);
                i > n && (n = i, r = e)
            }
            e.unshift(ne[r])
        }
        ne = e, ne.forEach((t => {
            Te.push(t[0]), Se.push(t[1])
        }))
    }(),
    function() {
        qt = new yt.PerspectiveCamera(45, jt / Ot, .1, 1e4), qt.position.z = 2.5, Qt = qt.position.z - .5, Zt = qt.position.z + .5, Nt = new yt.Scene, Nt.fog = new yt.Fog(re, Qt, Zt), Nt.background = re, Nt.add(qt), Bt = new yt.WebGLRenderer({
            antialias: !0,
            sortObjects: !1
        }), Bt.setPixelRatio(kt), Bt.setSize(jt, Ot), Re && (Bt.domElement.style.width = jt / 2 + "px", Bt.domElement.style.height = Ot / 2 + "px");
        Wt = new yt.Object3D, Nt.add(Wt), Bt.domElement.setAttribute("id", "scene"), document.body.appendChild(Bt.domElement), new yt.Mesh(new yt.PlaneBufferGeometry(.8, .8, 10, 10), new yt.MeshBasicMaterial({
            color: 16711680,
            side: yt.DoubleSide,
            wireframe: !0
        })), isFxpreview
    }(),
    function() {
        if (0 == c.random_int(0, 1)) {
            const t = new yt.PointLight(16777215, 1.5),
                e = new yt.DirectionalLight(16777215, .7),
                n = new yt.DirectionalLight(16777215, .4);
            t.position.set(-2, -2, -3), e.position.set(8, 8, 7), n.position.set(-2, 2, -2), Nt.add(t), Nt.add(e), Nt.add(n)
        } else {
            const t = new yt.PointLight(16777215, 1.5),
                e = new yt.DirectionalLight(16777215, .6),
                n = new yt.DirectionalLight(16777215, .5);
            t.position.set(2, 2, -3), e.position.set(8, -12, 7), n.position.set(-2, 2, -6), Nt.add(t), Nt.add(e), Nt.add(n)
        }
    }(),
    function() {
        let t = Math.floor(ye / 100);
        t < 1 && (t = 1);
        t = 1;
        let e = Math.ceil(ot.nSteps / 20);
        ot.nLines <= 250 && (e = Math.ceil(he / 8));
        ee = function(t, e, r, o, a, i, s, l) {
            let d = mt.ShaderLib.phong,
                v = mt.UniformsUtils.merge([d.uniforms, {
                    time: {
                        value: 0
                    }
                }, {
                    posTex: {
                        value: ft
                    }
                }]),
                g = d.vertexShader,
                u = d.fragmentShader;
            g = g.replace("#include <common>", `\n#include <common>\nvarying vec3 vPosition;\nvarying float hole;\nvarying float colorSelect;\nuniform float time;\nuniform sampler2D posTex;\n${n}\n`);
            let m = .75;
            m += ot.nSteps / 300 * .2, g = g.replace("#include <project_vertex>", `#include <project_vertex>\n  vPosition = transformed;\n\n  hole = 0.0;\n\n  vec3 pos = transformed.xyz;\n  vec3 p;\n  float rat;\n\n  float w = 1.0 / ${t.toPrecision(5)};\n\nfor (int i = 0; i < ${t}; i += ${r})\n{\nfor (int j = 0; j < ${o}; j++)\n{\np = texture2D(posTex, vec2(float(j) / ${o.toPrecision(5)}, float(i) / ${t.toPrecision(5)})).xyz;\nrat = 1.0 - clamp((length(p) - ${a}) / .1, 0.0, 1.0);\nhole += (1.0 - (clamp(length(pos - p) / ${ot.shellRepulsionDistance.toPrecision(5)}, 0.0, 1.0))) * ${ot.shellRepulsionStrength.toPrecision(5)} * rat;\n}\n\n}\n\nhole = clamp(hole, 0.0, 1.0);\nhole += cnoise(vec3(pos * ${ot.shellNoiseSize} + vec3(time * 0.1))) * 0.5;\n\nhole += clamp(${m.toPrecision(5)} - time * 0.055, 0.0, 1.0);\n\nhole +=  ${ot.shellOpenness.toPrecision(5)};\n\n\n//colorSelect = cnoise(vec3((pos + vec3(435.34)) * 2.3 + vec3(time * 0.01))) * 0.5;\n\n\n//color = vec4(1.0, 0.0, 0.0, 1.0);\n  `), u = u.replace("#include <common>", `\n#include <common>\nvarying vec3 vPosition;\nvarying float hole;\nvarying float colorSelect;\nuniform float time;\nuniform sampler2D posTex;\n${n}\n`);
            let f = c.random_int(0, i.length - 1),
                x = "c2 -= (1.0 - faceDir) * 0.7;";
            return c.random_dec() > .7 && (x = ""), u = u.replace("#include <fog_fragment>", `\n\nif (hole  > 0.2) discard;\n\nvec3 bgColor = vec3(${l.r.toPrecision(5)}, ${l.g.toPrecision(5)}, ${l.b.toPrecision(5)});\nvec3 c3 = vec3(${s[f].r.toPrecision(5)}, ${s[f].g.toPrecision(5)}, ${s[f].b.toPrecision(5)});\nvec3 c4 = vec3(${i[f].r.toPrecision(5)}, ${i[f].g.toPrecision(5)}, ${i[f].b.toPrecision(5)});\nfloat b2 = (bgColor.r + bgColor.g + bgColor.b) / 3.0;\nvec3 c1 = clamp(bgColor + vec3(.16 + (b2 * .2)), vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\nvec3 c2 = clamp(bgColor + vec3(-.1 + (b2 * .04)), vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n\nc3 -= .2;\nc4 -= .2;\n\n/*\n\nfloat cs = clamp(ceil(colorSelect * 2.0), 0.0, 1.0);\n\n//c1 = mix(c1, c4, cs);\n//c2 = mix(c2, c3, cs);\n\nif (colorSelect > .05)\n{\n//c1 += .09;\n//c2 -= .06;\n//c1 = c4;\n//c2 = c3;\n} \n*/\n\nfloat b = gl_FragColor.r;\nvec3 pos = vPosition.xyz;\n\n\n//float n = cnoise(vec3(pos * 2.3 + vec3(time * 0.1)));\n//if (n > 0.3 || hole  > 0.2) discard;\n\n\n\nfloat faceDir = gl_FrontFacing ? 1.0 : - 1.0;\n\n\nif (faceDir < 0.0)\n{\nc1 = c3;\nc2 = c4;\n}\n\n${x}\n\n\ngl_FragColor = vec4(mix(c2, c1, b), 1.0);\n\n\nfloat rotZ = atan(vPosition.x, vPosition.y);\nfloat rotX = atan(vPosition.z, vPosition.y);\n\n//float cr = sin(cos((vPosition.x * 34.0) * 31.0)) + cos((vPosition.y) * 43.45) + cos(vPosition.z * 42.3);\n//float cr = cnoise(vPosition.xyz * 2.1);\n//cr = sin(cr * 5.0);\n//cr += cnoise(vPosition.xyz * 10.1);\n//cr += cos(rotZ + rotX);\n\n\n\n//if (cr > 0.0 && cr < .1) discard;\n//else cr = 1.0;\n\n//cr = sin(rotX * 10.0);\n//cr += cos(rotZ * 10.0);\n//cr =  pow(1.0 - cr, 1.0);\n//gl_FragColor = vec4(cr, cr, cr, 1.0);\n\n\n#include <fog_fragment>\n`), new mt.ShaderMaterial({
                uniforms: v,
                vertexShader: g,
                side: mt.DoubleSide,
                wireframe: !1,
                fragmentShader: u,
                lights: !0,
                fog: !0,
                name: "core-mat",
                depthWrite: !0,
                flatShading: !1
            })
        }(ye, 0, t, e, ot.coreOuterRad, Te, Se, re);
        for (let t = 0; t < ot.nCores; t++) {
            let e = ot.coreInnerRad + t / ot.nCores.toPrecision(5) * (ot.coreOuterRad - ot.coreInnerRad),
                n = new yt.Mesh(new yt.SphereBufferGeometry(e, 120, 120), ee);
            Wt.add(n)
        }
    }(),
    function() {
        let t = new yt.SphereBufferGeometry(1, 100, 100),
            e = function() {
                let t = xt.ShaderLib.phong,
                    e = t.uniforms,
                    n = t.vertexShader,
                    r = t.fragmentShader;
                return n = n.replace("#include <common>", "\n#include <common>\n\nattribute vec3 shadowColor;\nattribute vec3 lightColor;\n\nvarying vec3 sColor;\nvarying vec3 lColor;\n"), n = n.replace("#include <fog_vertex>", "\n#include <fog_vertex>\n\nsColor = shadowColor;\nlColor = lightColor;\n"), r = r.replace("#include <common>", "\n#include <common>\n\nvarying vec3 sColor;\nvarying vec3 lColor;\n"), r = r.replace("#include <fog_fragment>", "\n\nvec3 c2 = lColor;\nvec3 c1 = sColor;\nfloat b = gl_FragColor.r;\n\n\ngl_FragColor = vec4(mix(c1, c2, b), 1.0);\n#include <fog_fragment>\n"), new xt.ShaderMaterial({
                    uniforms: e,
                    vertexShader: n,
                    fragmentShader: r,
                    lights: !0,
                    fog: !0,
                    name: "base-mat",
                    depthWrite: !0,
                    flatShading: !1
                })
            }(),
            n = ot.numPlanets;
        Jt = new yt.InstancedMesh(t, e, n);
        let r = Te.slice(),
            o = Se.slice(),
            a = De(re);
        r.unshift(a[0]), o.unshift(a[1]);
        let i = [],
            s = [];
        for (let t = 0; t < n; t++) {
            let e = {};
            ot.centerPlanet && 0 == t ? (e.rotationY = e.rotationZ = e.rad = 0, ot.coreInnerRad > .2 && (ot.coreInnerRad = .2), e.scale = c.random_num(.04, ot.coreInnerRad), e.rad = 1e-7) : (e.scale = .02 + .08 * Math.pow(c.random_dec(), 3), e.rotationY = -Math.PI + c.random_dec() * Math.PI * 2, e.rotationZ = -Math.PI + c.random_dec() * Math.PI * 2, e.rad = ot.coreOuterRad + .3 * c.random_dec());
            let n = Math.floor(Math.pow(c.random_dec(), 2) * r.length),
                a = r[n],
                l = o[n];
            s.push(a.r, a.g, a.b), i.push(l.r, l.g, l.b), fe.push(e)
        }
        Jt.geometry.setAttribute("shadowColor", new THREE.InstancedBufferAttribute(new Float32Array(i), 3, !1)), Jt.geometry.setAttribute("lightColor", new THREE.InstancedBufferAttribute(new Float32Array(s), 3, !1)), Wt.add(Jt)
    }(), Ee(),
        function() {
            bt = new t(he, ye, Bt), Tt = bt.createTexture(), St = bt.addVariable("textureTargetPosition", function(t, e) {
                return `\n\n#define PI 3.1415926538\n${r}\n${o}\n\n// Triangle intersection. Returns { t, u, v }\nvec3 triIntersect( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 v1v0 = v1 - v0;\n    vec3 v2v0 = v2 - v0;\n    vec3 rov0 = ro - v0;\n\n#if 1\n    // Cramer's rule for solcing p(t) = ro+t·rd = p(u,v) = vo + u·(v1-v0) + v·(v2-v1)\n    float d = 1.0/determinant(mat3(v1v0, v2v0, -rd ));\n    float u =   d*determinant(mat3(rov0, v2v0, -rd ));\n    float v =   d*determinant(mat3(v1v0, rov0, -rd ));\n    float t =   d*determinant(mat3(v1v0, v2v0, rov0));\n#else\n    // The four determinants above have lots of terms in common. Knowing the changing\n    // the order of the columns/rows doesn't change the volume/determinant, and that\n    // the volume is dot(cross(a,b,c)), we can precompute some common terms and reduce\n    // it all to:\n    vec3  n = cross( v1v0, v2v0 );\n    vec3  q = cross( rov0, rd );\n    float d = 1.0/dot( rd, n );\n    float u = d*dot( -q, v2v0 );\n    float v = d*dot(  q, v1v0 );\n    float t = d*dot( -n, rov0 );\n#endif    \n\n    if( u<0.0 || v<0.0 || (u+v)>1.0 ) t = -1.0;\n    \n    return vec3( t, u, v );\n}\n\n\nuniform float time;\nuniform int frame;\nuniform float mouseRat;\nuniform sampler2D headVertTex;\nuniform float headVertTexSize;\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\n${lt}\n\nvoid main () {\n\nvec2 uv = gl_FragCoord.xy / resolution.xy;\nvec4 targetPos = texture2D(textureTargetPosition, uv);\nvec4 pos;\nfloat type = floor(pow(sin(uv.y * 1234.5), ${ot.typeDistPow.toPrecision(5)}) * ${e.toPrecision(5)});\n\ntype = pow(uv.y, ${ot.typeDistPow.toPrecision(5)}) * ${e.toPrecision(5)};\n\nif (gl_FragCoord.x <= 1.0) // calculate first position\n{\nvec3 p;\n${t}\npos.xyz = p;\npos.w = type;\n}\n\n\ngl_FragColor = pos;\n}`
            }(Ce, ne.length), Tt), St.material.uniforms.time = {
                value: 0
            }, St.material.uniforms.frame = {
                value: de
            }, St.material.uniforms.mouseRat = {
                value: we
            }, Mt = bt.createTexture(), $t = bt.addVariable("texturePosition", `\nuniform float time;\nuniform int frame;\n\n${n}\n\nvoid main () {\n\nvec4 pos;\nvec2 uv = gl_FragCoord.xy / resolution.xy;\nvec4 acc = texture2D(textureAcc, uv);\n\nif (frame == 0)\n{\npos = texture2D(textureTargetPosition, uv);\n}\nelse if (gl_FragCoord.x <= 1.0) // calculate first position\n{\n\nvec4 vel = texture2D(textureVel, uv);\n\npos = texture2D(texturePosition, uv);\npos.xyz += vel.xyz;\npos.w = vel.w;\n\n  if (${ot.glitch} && cnoise(vec3(pos.xyz + ( time * 100.0 * (uv.y * 100.0)) )) > .85)\n  {\n  float s = 2.0 + (cnoise(vec3(pos.xyz)) * 5.0);\n\n  float dir = cnoise(vec3(pos.xyz)) > 0.0 ? -.5 : .5;\n  dir = -.5;\n  pos.xyz += vec3(0.0, dir, 0.0) * s * 0.4;\n  //acc = normalize(acc);\n  }\n}\nelse // repeat previous position\n{\nvec2 fc = gl_FragCoord.xy;\nfc.x -= 1.0;\nuv = fc / resolution.xy;\npos = texture2D( texturePosition, uv );\n\n}\n\ngl_FragColor = pos;\n}`, Mt), $t.material.uniforms.time = {
                value: 0
            }, $t.material.uniforms.frame = {
                value: de
            }, $t.material.uniforms.mouseRat = {
                value: we
            }, Rt = bt.createTexture(), Ct = bt.addVariable("textureAcc", `\n\nuniform float maxAcc;\nuniform float time;\nuniform vec4 repulsors[${ot.numPlanets}];\n\nvoid main () {\nvec2 uv = gl_FragCoord.xy / resolution.xy;\nvec3 pos = texture2D(texturePosition, uv).xyz;\n  vec4 targetPos = texture2D(textureTargetPosition, uv);\n  float type = targetPos.w;\n\n  vec3 acc = (targetPos.xyz - pos);\nfloat l = length(acc);\nacc = clamp(acc, vec3(-maxAcc), vec3(maxAcc)) * maxAcc;\n\nfor (int i = 0; i < ${ot.numPlanets}; i++)\n{\nvec4 rep = repulsors[i];\nvec3 distVec = targetPos.xyz - rep.xyz;\nvec3 dir = normalize(distVec);\nfloat distRat = 1.0 - clamp((length(distVec) - rep.w) / (rep.w + 0.05), 0.0, 1.0);\n\nacc += dir * distRat * 0.1;\n}\n\nif (type >= 100.0) // stray particle\n{\nfloat dist = length(targetPos.xyz);\nvec3 dir = normalize(targetPos.xyz);\nfloat distRat = 1.0 - clamp((dist - ${ot.coreOuterRad.toPrecision(5)}) / .1, 0.0, 1.0);\n\nacc += dir * distRat * 0.5;\n}\n\n  gl_FragColor = vec4(acc, targetPos.w);\n\n\n}`, Rt), Ct.material.uniforms.maxAcc = {
                value: me
            }, Ct.material.uniforms.time = {
                value: 0
            }, Ct.material.uniforms.repulsors = {
                value: xe
            }, Dt = bt.createTexture(), Et = bt.addVariable("textureVel", "\nvoid main () {\nvec2 uv = gl_FragCoord.xy / resolution.xy;\nvec4 pos = texture2D(texturePosition, uv);\n  vec4 acc = texture2D(textureAcc, uv);\n  vec4 vel = texture2D(textureVel, uv);\n\n  vel.xyz *= 0.95;\n  vel.xyz += acc.xyz * 0.01;\n\n  gl_FragColor = vec4(vel.xyz, acc.w);\n}", Dt), Ft = bt.createTexture(), At = bt.addVariable("textureTangent", "\nvoid main () \n{\nvec3 pos = texture2D(texturePosition, gl_FragCoord.xy / resolution.xy).xyz;\nvec3 prevPos = texture2D(texturePosition, (gl_FragCoord.xy + vec2(1.0, 0.0)) / resolution.xy).xyz;\nvec3 nextPos = texture2D(texturePosition, (gl_FragCoord.xy - vec2(1.0, 0.0)) / resolution.xy).xyz;\n\nvec3 tangent = normalize(nextPos - pos);\n\ngl_FragColor = vec4(tangent.xyz, 1.0);\n}", Ft), Ht = bt.createTexture(), Lt = bt.addVariable("textureYDir", "\nvoid main () \n{\nvec3 tan = texture2D(textureTangent, gl_FragCoord.xy / resolution.xy).xyz;\nvec3 nextTan = texture2D(textureTangent, (gl_FragCoord.xy - vec2(1.0, 0.0)) / resolution.xy).xyz;\nvec3 yDir = cross(tan, normalize(nextTan - tan));\n\n\nif (gl_FragCoord.x > 1.0) // repeat previous position\n{\nvec2 fc = gl_FragCoord.xy;\nfc.x -= 1.0;\nvec2 uv = fc / resolution.xy;\nyDir = texture2D( texturePosition, uv ).xyz;\n}\n\nyDir = normalize(yDir);\ngl_FragColor = vec4(yDir.xyz, 1.0);\n}", Ht), It = bt.createTexture(), Vt = bt.addVariable("textureXDir", "\nvoid main () \n{\nvec3 tan = texture2D(textureTangent, gl_FragCoord.xy / resolution.xy).xyz;\nvec3 yDir = texture2D(textureYDir, gl_FragCoord.xy / resolution.xy).xyz;\nvec3 xDir = normalize(cross(tan, yDir));\n\ngl_FragColor = vec4(xDir.xyz, 1.0);\n}", It), bt.setVariableDependencies(St, [$t, St]), bt.setVariableDependencies(Ct, [$t, St]), bt.setVariableDependencies(Et, [$t, Ct, Et]), bt.setVariableDependencies($t, [$t, St, Ct, Et]), bt.setVariableDependencies(At, [$t]), bt.setVariableDependencies(Lt, [$t, At]), bt.setVariableDependencies(Vt, [$t, At, Lt]), te = new yt.WebGLRenderTarget(jt * ge, Ot * ge, {
                depthBuffer: !0
            });
            var e = bt.init();
            null !== e && console.error(e)
        }(),
        function() {
            let t = function(t, e) {
                    let n = new yt.PlaneBufferGeometry(.005, .5, 1, e);
                    if (t > 2) {
                        n = new THREE.BufferGeometry;
                        let r = [],
                            o = [],
                            a = 2 * Math.PI / t;
                        for (let n = 0; n < e; n++)
                            for (let i = 0; i < t; i++) {
                                let s = a * i;
                                if (r.push(.1 * Math.cos(s), .1 * Math.sin(s), .01 * n), r.push(.1 * Math.cos(s), .1 * Math.sin(s), .01 * n), n < e - 1) {
                                    let e = n * t * 2 + 2 * i + 1,
                                        r = e + 2 * t;
                                    i < t - 1 ? (o.push(e, e + 1, r), o.push(e + 1, r + 1, r)) : (o.push(e, e - 2 * t + 1, r), o.push(e - 2 * t + 1, r - 2 * t + 1, r))
                                }
                            }
                        n.setIndex(o), n.setAttribute("position", new THREE.BufferAttribute(new Float32Array(r), 3))
                    }
                    return n
                }(pe, he),
                e = function(t, e, a, i, s, c) {
                    let l = gt.UniformsUtils.merge([gt.ShaderLib.phong.uniforms, {
                            diffuse: {
                                value: new gt.Color(16777215)
                            }
                        }, {
                            time: {
                                value: 0
                            }
                        }, {
                            numSteps: {
                                value: 0
                            }
                        }, {
                            nSides: {
                                value: a
                            }
                        }, {
                            posTex: {
                                type: ut
                            }
                        }, {
                            xDirTex: {
                                value: ut
                            }
                        }, {
                            yDirTex: {
                                value: ut
                            }
                        }, {
                            tanTex: {
                                value: ut
                            }
                        }, {
                            mouseRat: {
                                value: 0
                            }
                        }, {
                            lightColors: {
                                value: s
                            }
                        }, {
                            shadowColors: {
                                value: c
                            }
                        }]),
                        d = gt.ShaderLib.phong.vertexShader,
                        v = gt.ShaderLib.phong.fragmentShader;
                    d = d.replace("#include <common>", `\n  ${o}\n  ${r}\n\n  #include <common>\n  uniform float time;\n  uniform int numSteps;\n  uniform int nSides;\n\n  attribute int indexAttr;\n  attribute int nTotalAttr;\n  attribute int thicknessAttr;\n\n  uniform sampler2D posTex;\n  uniform sampler2D xDirTex;\n  uniform sampler2D yDirTex;\n  uniform sampler2D tanTex;\n  uniform float mouseRat;\n\n  varying vec4 vPosition;\n  varying vec4 mvPosition;\n  varying vec3 color;\n  varying float type;\n  varying float indexRat;\n  varying float lengthRad;\n  varying float circRad;\n\n  uniform vec3 lightColors[${i}];\n  uniform vec3 shadowColors[${i}];\n\n  varying vec3 c1;\n  varying vec3 c2;\n  varying vec3 c3;\n  varying vec3 c4;\n  \n  `);
                    let g = "thickness *= pow(1.0 - lengthRad, shapePow); shapeType = 0;",
                        u = "thickness *= lengthRad < .5 ? lengthRad * 2.0 : 1.0 - ((lengthRad - 0.5) * 2.0); shapeType = 3;",
                        m = `\n//int shapeType = int(1.0 + sin(uv.y * 342.3) * 3.0);\nint sType = iType;\n\nif (sType == 0)\n{\n${g}\n}\nelse if (sType == 1)\n{\n${u}\n}\n`,
                        f = "";
                    switch (ot.ribbonType) {
                        case 0:
                        case 1:
                            f += g;
                            break;
                        case 2:
                            f += g, f += "thickness *= 1.0 + (sin(uv.x * 14.0) * (nX * 0.01));";
                            break;
                        case 3:
                            f += u;
                            break;
                        case 4:
                            f += m
                    }
                    let x = "";
                    return ot.spikey && (x = "if (type >= 1.0) tanCpy.xyz *= sin(uv.y + 343.3 + (time * .5)) * -10.0;"), d = d.replace("#include <project_vertex>", `\n  float i = float(indexAttr);\nfloat nTotal = float(nTotalAttr);\n\n\nfloat thickness = float(thicknessAttr) / 100000.0;\nfloat nX = ${t.toPrecision(5)};\nfloat nY = ${e.toPrecision(5)};\nfloat mScale = ${1..toPrecision(5)};\n\nfloat y = i + .001; // fix gpu rounding issue\n\nint stepIndex = ((gl_VertexID/2) / nSides) + 1;\nfloat x = float(stepIndex) + .001;\n\n\nindexRat = y / nY;\nfloat yRat = y / nY;\nvec2 uv = vec2(x / nX, yRat);\nvec2 uv2 = vec2(((x + 1.0) / nX), yRat);\nvec4 pos = texture2D(posTex, uv);\nvec4 prevPos = texture2D(posTex, uv2);\nvec4 tan = texture2D(tanTex, uv);\nvec4 xDir = texture2D(xDirTex, uv);\nvec4 yDir = texture2D(yDirTex, uv);\ntype = pos.w;\n\nif (type >= 100.0) type -= 100.0;\nint iType = int(floor(type));\n\nvec4 position = vec4( transformed, 1.0 ); //weird firefox bug, don't remove this line\nposition = vec4(pos.xyz, 1.0);\n\nfloat maxSteps = (float(numSteps-4) < nTotal ? float(numSteps-4) : nTotal) - 1.0;\nlengthRad = x / maxSteps;\n\nfloat shapePow = 1.0;\nint shapeType = 0;\n${f}\n\nthickness *= .7 + (pow(cnoise(vec4(pos.xyz, time * ${ot.thicknessVarySpeed})), 2.0) * 10.0);\nvNormal = yDir.xyz;\n\nfloat mult = 1.0 - floor(clamp(float(stepIndex) / maxSteps, 0.0, 1.0));\nthickness *= mult;\n\nfloat radStep = (PI * 2.0) / float(nSides);\n\nfor (int j = 0; j < nSides; j++)\n{\nif (((gl_VertexID / 2) + j) % nSides == 0)\n{\nvec3 dir = rotAxis(xDir.xyz, tan.xyz, radStep * float(j));\n\n\nif (stepIndex < 6 && shapeType < 3) \n{\nvec4 tanCpy = tan;\n${x}\nposition = vec4(prevPos.xyz + tanCpy.xyz * thickness * 2.0, 1.0); //make pointy tip\n}\nelse\n{\nposition += vec4(dir, 0.0) * thickness;\n}\n\n\ncircRad = float(j) / float(nSides);\n\nvNormal = rotAxis(xDir.xyz, tan.xyz, radStep * (float(j) - 0.5));\n\nif ((gl_VertexID + 1) % 2 == 0)\n{\nvNormal = rotAxis(xDir.xyz, tan.xyz, radStep * (float(j) - 0.5));\n}\nelse\n{\nvNormal = rotAxis(xDir.xyz, tan.xyz, radStep * (float(j) + 0.5));\n}\n}\n}\n\nvNormal = normalMatrix * vNormal;\n\n//type = (1.0 + cnoise(vec4(pos.xyz * .5, time * 0.1)) ) / 2.0;\n//type = (1.0 + cnoise(vec4(lengthRad * 0.2 + (y* 0.01), lengthRad * 0.2, lengthRad * 0.2, time * 0.1)) ) / 2.0;\n//type *= ${i.toPrecision(5)};\n\nvPosition = position;\nmvPosition = modelViewMatrix * position;\ngl_Position = projectionMatrix * mvPosition;\n\nint t = iType;\n\nc1 = lightColors[t];\nc2 = shadowColors[t];\n\nint add = sin(y * 1423.4) > -0.3 ? 1 : 0;\n\nc3 = lightColors[t + add];\nc4 = shadowColors[t + add];\n\n//color = vec3(1.0, 1.0, 1.0);\n//if (stepIndex <= 0) color = vec3(0.0, 0.0, 0.0);\n  `), v = v.replace("#include <common>", `\n#include <common>\nuniform vec3 lightColors[${i}];\nuniform vec3 shadowColors[${i}];\nuniform float time;\nvarying vec4 vPosition;\nvarying vec4 mvPosition;\nvarying vec3 color;\nvarying float type;\nvarying float indexRat;\nvarying float lengthRad;\nvarying float circRad;\n\nvarying vec3 c1;\nvarying vec3 c2;\nvarying vec3 c3;\nvarying vec3 c4;\n\n${n}\n\n//varying vec3 vNormal;\n\n//#define FLAT_SHADED TRUE\n`), v = v.replace("#include <fog_fragment>", "\nfloat b = gl_FragColor.r;\n\n//b = pow(b * 1.5, 2.0);\n\nfloat cb = (c2.r + c2.g + c2.b) / 3.0;\n\nif (cb < .2)\n{\nb = pow(b, 1.5);\n}\nelse\n{\nb = 1.0 - pow(1.0 - b, 1.7);\n}\n\nb = clamp(b, 0.0, 1.0);\n\n//float dis = cnoise(vec3(lengthRad * 4.1 + mvPosition.x * 3.4, circRad * 23.3 + mvPosition.y * 4.3, mvPosition.x * 3.5 + (time * 0.7) ));\n//if (dis > -0.1) discard;\n\n//c1 = vec3(sin(indexRat * 123.4), sin(indexRat * 1343.4), sin(indexRat * 153.4)) + vec3(.1);\n//c2 = c2 - vec3(.1);\n\nvec4 col1 = vec4(mix(c2, c1, b), 1.0);\nvec4 col2 = vec4(mix(c4, c3, b), 1.0);\n\ngl_FragColor = mix(col1, col2, lengthRad);\n//gl_FragColor.rgb *=  1.0 + (vec3(pow(1.0 - lengthRad, 2.0)) * .3);\n//gl_FragColor.rgb += (vec3(pow(1.0 - lengthRad, 2.0)) * .5;\n\n//gl_FragColor = vec4(vNormal, 1.0);\n\n\n\n#include <fog_fragment>\n"), new gt.ShaderMaterial({
                        uniforms: l,
                        vertexShader: d,
                        side: gt.DoubleSide,
                        wireframe: !1,
                        fragmentShader: v,
                        lights: !0,
                        fog: !0,
                        name: "custom-material",
                        depthWrite: !0
                    })
                }(he, ye, pe, ne.length, Te, Se);
            Kt = new yt.InstancedMesh(t, e, ye);
            let a = [],
                i = [],
                l = [];
            for (let t = 0; t < ye; t++) {
                let e = c.random_num(.1, 1);
                ot.shortenRibbons && c.random_bool(.5) && (e *= .2);
                let n = ot.minThickness;
                c.random_dec() < ot.thinProbability && (n *= .15);
                let r = Math.floor(s(e, 0, 1, 5, he));
                l.push(1e5 * n), a.push(t), i.push(r)
            }
            Kt.geometry.setAttribute("indexAttr", new THREE.InstancedBufferAttribute(new Int32Array(a), 1, !1)), Kt.geometry.setAttribute("nTotalAttr", new THREE.InstancedBufferAttribute(new Int32Array(i), 1, !1)), Kt.geometry.setAttribute("thicknessAttr", new THREE.InstancedBufferAttribute(new Int32Array(l), 1, !1)), Wt.add(Kt)
        }(),
        function() {
            var t = yt.ShaderLib.basic.vertexShader,
                e = function(t) {
                    return `\n  uniform sampler2D map;\n  uniform sampler2D debugMap;\n\n  uniform float time;\n  uniform float width;\n  uniform float height;\n  uniform float noiseStrength;\n\n  ${r}\n\n  float random( vec2 p )\n  {\n    vec2 K1 = vec2(\n      23.14069263277926,\n      2.665144142690225\n    );\n    return fract( cos( dot(p,K1) ) * 12345.6789 );\n  }\n\n  float rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n  }\n\n  float sSin(float x)\n  {\n    return (1.0 + sin(x)) / 2.0;\n  }\n\n  float hash12(vec2 p)\n  {\n      vec3 p3  = fract(vec3(p.xyx) * .1031);\n      p3 += dot(p3, p3.yzx + 33.33);\n      return fract((p3.x + p3.y) * p3.z);\n  }\n\n  void main ()\n  {\n  float pixR = ${t.toPrecision(6)};\n  vec2 fc = gl_FragCoord.xy;\n  vec2 uv = fc / vec2(width * pixR, height * pixR);\n  vec4 c = texture2D( map, uv);\n    //c = abs(c);\n    //c.xyz *= 0.5;\n\n  //float n = random(uv * (10.123 + sin(time * 0.01) * .723));\n    float n = hash12(gl_FragCoord.xy + time);\n    //n = rand(uv + vec2(n, n * time));\n  gl_FragColor = c;\n  \n  float bri = (gl_FragColor.r + gl_FragColor.g + gl_FragColor.b) / 3.0;\n\n  ${pt}\n  \n  gl_FragColor = gl_FragColor * .95 + pow(vec4(n, n, n, 1.0), vec4(1.0)) * .08 * (1.0 - bri) * noiseStrength;\n  gl_FragColor += pow(vec4(n, n, n, 1.0), vec4(1.0)) * ((.013 + (bri * .12))) * noiseStrength;\n    //gl_FragColor += vec4(n, n, n, 1.0);\n    gl_FragColor = clamp(gl_FragColor, vec4(0.0), vec4(1.0));\n  }`
                }(kt),
                n = yt.UniformsUtils.merge([yt.ShaderLib.basic.uniforms, {
                    time: {
                        value: 0
                    }
                }, {
                    width: {
                        value: jt
                    }
                }, {
                    height: {
                        value: Ot
                    }
                }, {
                    noiseStrength: {
                        value: 1
                    }
                }]);
            Xt = new yt.ShaderMaterial({
                uniforms: n,
                vertexShader: t,
                fragmentShader: e,
                name: "filter-material"
            }), Gt = new yt.Scene, Gt.background = new yt.Color(0, 0, 0), Ut = new yt.OrthographicCamera(jt / -2, jt / 2, Ot / 2, Ot / -2, -1e4, 1e4), Ut.position.z = 1, Yt = new yt.Mesh(new yt.PlaneBufferGeometry(1, 1), Xt), Yt.scale.x = jt, Yt.scale.y = Ot, Gt.add(Yt), oe = new yt.Scene, oe.background = new yt.Color(0, 0, 0), ae = new yt.Object3D;
            let o = 1 / 3,
                a = [];
            a.push(bt.getCurrentRenderTarget(Et).texture), a.push(bt.getCurrentRenderTarget(Ct).texture), a.push(bt.getCurrentRenderTarget($t).texture), a.push(bt.getCurrentRenderTarget(At).texture), a.push(bt.getCurrentRenderTarget(Vt).texture), a.push(bt.getCurrentRenderTarget(Lt).texture);
            let i = 0;
            for (let t = 0; t < 2; t++)
                for (let e = 0; e < 3; e++) {
                    let n = new yt.Mesh(new yt.PlaneBufferGeometry(o, .5), new yt.MeshBasicMaterial);
                    0 == i ? n.material.color = new yt.Color(15, 15, 15, 0) : 1 == i && (n.material.color = new yt.Color(5, 5, 5, 0)), n.position.x = -.5 * (1 - o) + o * e, n.position.y = .25 - .5 * t, n.material.map = a[i], n.material.map.offset = new yt.Vector2(1 / he * 2, 0), ae.add(n), i++
                }
            ae.position.x = -.5, ae.position.y = .5, ae.scale.x = jt, ae.scale.y = Ot, oe.add(ae)
        }(),
        function t() {
            var e = Me();
            let n = (e - le) / 1e3,
                r = 1 / n;
            n = 1 / 30, se += n, le = e, ve >= 30 ? (r > 80 && ve % 2 == 0 || $e(n), be ? Bt.domElement.toBlob((function(t) {
                be = !1, a(t, "face_" + de.toString().padStart(3, "0") + ".png"), o()
            })) : o()) : 29 == ve ? (se = 0, o()) : o();

            function o() {
                requestAnimationFrame(t), ve++
            }
        }(), $e(0), window.addEventListener("resize", (t => {
            jt = window.innerWidth, Ot = window.innerHeight, Re && (jt *= 2, Ot *= 2), qt.aspect = jt / Ot, qt.updateProjectionMatrix(), Bt.setSize(jt, Ot), Re && (Bt.domElement.style.width = jt / 2 + "px", Bt.domElement.style.height = Ot / 2 + "px"), Ut = new yt.OrthographicCamera(jt / -2, jt / 2, Ot / 2, Ot / -2, -1e4, 1e4), Ut.updateProjectionMatrix(), te = new yt.WebGLRenderTarget(jt * ge, Ot * ge, {
                depthBuffer: !0
            }), Yt.scale.x = jt, Yt.scale.y = Ot, ae.scale.x = jt, ae.scale.y = Ot
        })), document.addEventListener("keydown", (t => {
            "Space" == t.code ? ue = !ue : "KeyD" == t.code ? ze = !ze : "KeyS" == t.code ? be = !0 : "KeyW" == t.code && (_e = !_e)
        })), window.addEventListener("mousemove", (function(t) {
            ie = !0;
            let e = Bt.domElement.getBoundingClientRect(),
                n = e.x + .5 * e.width,
                r = e.y + .5 * e.height,
                o = Math.sqrt(Math.pow(t.pageX - n, 2), Math.pow(t.pageY - r, 2)) / (.5 * Bt.domElement.offsetWidth);
            we = o
        }));
    let Fe = function() {
        let t = ot,
            e = ["Piti", "Sukha", "Metta", "Samadhi", "Jhana", "Satori", "Papancha", "Kensho"][t.colorSchemeIndex],
            n = ["Hard", "Hard", "Soft", "Sharp", "Mixed"][t.ribbonType],
            r = "(" + t.torusP + "," + t.torusQ + ")-Knot";
        t.torusExtraRev || (r = "Circular");
        let o = "A lot";
        t.nLines < 1e3 && (o = "Many"), t.nLines < 200 && (o = "Several"), t.nLines < 61 && (o = "Few");
        let a = "Long";
        return t.nSteps < 150 && (a = "Medium"), t.nSteps < 80 && (a = "Short"), t.nSteps < 20 && (a = "Very Short"), {
            "Base Color Scheme": e,
            "Color Scheme Variation": g + 1,
            "Number of Accent Colors": t.numColors,
            Quantity: o,
            "Trail Length": a,
            Quality: n,
            Glitchy: at(t.glitch),
            Aggressive: at(t.spikey),
            "Base Trajectory": r,
            Spherized: at(t.spherize),
            Twisted: at(t.extraRev),
            Core: at(t.centerPlanet),
            Layers: t.nCores,
            Spheres: t.numPlanets
        }
    }();
    window.$fxhashFeatures = Fe, console.log("FEATURES -------------------------");
    for (const [t, e] of Object.entries(Fe)) console.log(`${t}: ${e}`);
    console.log("----------------------------------")
}();